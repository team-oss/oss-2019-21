---
title: "International Country Networks: Supernode Analyses"
author: "Brandon L. Kramer"
output: html_document
---

## Loading Data 

We used this code to pull data for the construction of Github network data (cumulatively.

```{r loading edgelist data, warning=FALSE, echo=FALSE}
rm(list = ls())
# install.packages(c("tidyverse", "igraph", "visNetwork", "bc3net", 
# "data.table", "R.utils", "RPostgreSQL", "cowplot", "maditr", "linkprediction", "poweRlaw"))

# load packages 
for (pkg in c("tidyverse", "igraph", "visNetwork", "bc3net", "data.table", "R.utils", "RPostgreSQL",
              "cowplot", "maditr", "lubridate", "linkprediction", "poweRlaw")) {library(pkg, character.only = TRUE)}

# connect to postgresql to get data (in rivanna)
conn <- dbConnect(drv = PostgreSQL(), dbname = "sdad_data", 
                  host = "sdad.policy-analytics.net", port = 5436, 
                  user = Sys.getenv("db_userid"), password = Sys.getenv("db_pwd"))

# query the bipartite edgelist data from github data  
bp_edgelist <- dbGetQuery(conn, "SELECT login, slug, year, weight 
                                 FROM github.intl_dyn_bp_edges 
                                  WHERE year > 2007 AND year < 2019")
                                #WHERE year = 2008")
                                #WHERE year > 2007 AND year < 2010")
                                #WHERE year > 2007 AND year < 2011")
                                #WHERE year > 2007 AND year < 2012")
                                #WHERE year > 2007 AND year < 2013")
                                #WHERE year > 2007 AND year < 2014")
                                #WHERE year > 2007 AND year < 2015")
                                #WHERE year > 2007 AND year < 2016")
                                #WHERE year > 2007 AND year < 2017")
                                #WHERE year > 2007 AND year < 2018")
                                #WHERE year > 2007 AND year < 2019")

conn <- dbConnect(drv = PostgreSQL(), dbname = "sdad_data", 
                  host = "sdad.policy-analytics.net", port = 5436, 
                  user = Sys.getenv("db_userid"), password = Sys.getenv("db_pwd")

# query the bipartite edgelist data from github data  
country_codes <- dbGetQuery(conn, "SELECT login, country_code
                                   FROM github.users_gh_cc")

country_codes <- country_codes %>% 
  rename(country = country_code) %>% 
  filter(!grepl(",", country)) %>% 
  filter(!grepl("europe", country)) %>% 
  filter(!grepl("americas", country)) %>% 
  filter(!grepl("asia", country)) %>% 
  filter(!grepl("africa", country)) %>% 
  mutate(country = trimws(country))

country_codes %>% 
  group_by(country) %>% 
  count()


bp_edgelist <- inner_join(bp_edgelist, country_codes, by = "login") %>% 
  select(-login) %>% rename(login = country) %>% 
  select(login, slug, year, weight)

# disconnect from postgresql
dbDisconnect(conn)

```


```{r network stats}
# in this snippet, we will be logging start/end times 
mat_start <- data.frame(event="mat_start", time=now("EST"))

# this code is taken from network scientists to reduce bipartite networks to single mode networks 
bp_matrix <- spMatrix(nrow=length(unique(bp_edgelist$login)),
              ncol=length(unique(bp_edgelist$slug)),
              i = as.numeric(factor(bp_edgelist$login)),
              j = as.numeric(factor(bp_edgelist$slug)),
              x = rep(1, length(as.numeric(bp_edgelist$login))))
row.names(bp_matrix) <- levels(factor(bp_edgelist$login))
colnames(bp_matrix) <- levels(factor(bp_edgelist$slug))
#rm(bp_edgelist) # trying to minimize weight on RAM 

# logging the times and saving the work in RDS files 
mat_end <- data.frame(event="mat_end", time=now("EST"))
time_log <- rbind(mat_start, mat_end); rm(mat_start, mat_end)
#saveRDS(bp_matrix, "bp_matrix.rds")
saveRDS(time_log, "time_log.rds")

# logging the times 
mm_start <- data.frame(event="mm_start", time=now("EST"))
time_log <- rbind(time_log, mm_start)

# we then multiply these incidence matrices and impute zeroes to prevent self loops 
login_matrix <- tcrossprod(bp_matrix)
diag(login_matrix) <- 0
rm(bp_matrix)

# logging the times and saving the work in RDS files 
mm_end <- data.frame(event="mm_end", time=now("EST"))
time_log <- rbind(time_log, mm_end); rm(mm_start, mm_end)
#saveRDS(login_matrix, "login_matrix.rds")
saveRDS(time_log, "time_log.rds")

# convert it into a network and removing the loops 
net_start <- data.frame(event="net_start", time=now("EST"))
time_log <- rbind(time_log, net_start); rm(net_start)
login_network <- graph_from_adjacency_matrix(login_matrix, mode = "undirected", weighted = TRUE)
login_network <- simplify(login_network, remove.loops = TRUE)

# logging the times and saving the work in RDS files 
net_end <- data.frame(event="net_end", time=now("EST"))
time_log <- rbind(time_log, net_end); rm(net_end)
#saveRDS(login_network, "login_network.rds")
saveRDS(time_log, "time_log.rds")
```

```{r}

# getting the weighted edgelist from 
g  <- graph.adjacency(login_matrix, weighted=TRUE)
df <- get.data.frame(g)
head(df)
df <- df %>% 
  filter(weight != 0) %>% 
  rename(Source = from, Target = to, Weight = weight)
df
write_csv(df, "country_edgelist.csv")

```

```{r global network stats}
# loading the network (if the instance crashes while doing network_stats)
#login_network <- readRDS("login_network.rds")
#time_log <- readRDS("time_log.rds")
net_stats_start <- data.frame(event="net_stats_start", time=now("EST"))
time_log <- rbind(time_log, net_stats_start); rm(net_stats_start)
network_stats <- data.frame(year="2008-18")                                          

# node and edge counts  
network_stats$node_count <- gorder(login_network)  
network_stats$edge_count <- gsize(login_network)
network_stats$commits <- sum(bp_edgelist$weight)

# isolates, dyads and triads 
network_stats$isolates <- sum(degree(login_network)==0)
network_stats$dyads <- dyad_census(login_network)[1]
#oss_triads <- triad.census(login_network)
#network_stats$triads_003 <- oss_triads[1] 
#network_stats$triads_102 <- oss_triads[3]
#network_stats$triads_201 <- oss_triads[11]
#network_stats$triads_300 <- oss_triads[16]
net_counts <- data.frame(event="net_counts", time=now("EST"))
time_log <- rbind(time_log, net_counts); rm(net_counts)

# density and transitivity
network_stats$density <- edge_density(login_network, loops=FALSE) 
network_stats$transitivity <- transitivity(login_network)
net_globals <- data.frame(event="net_globals", time=now("EST"))
time_log <- rbind(time_log, net_globals); rm(net_globals)



# diameter and mean distance (very computationally intensive)
#network_stats$diameter <- diameter(login_network)
#network_stats$mean_distance <- mean_distance(login_network, directed=FALSE)

# community detection (using louvain method)
louvain <- cluster_louvain(login_network)
network_stats$louvain <- modularity(louvain)
network_stats$louvain_scaled <- modularity(louvain) / gorder(login_network)
network_stats$louvain_logged <- modularity(louvain) / log(gorder(login_network))
# community detection (using fast & greedy method)
fstgrdy <- fastgreedy.community(login_network)
network_stats$fstgrdy <- modularity(fstgrdy)
network_stats$fstgrdy_scaled <- modularity(fstgrdy) / gorder(login_network)
network_stats$fstgrdy_logged <- modularity(fstgrdy) / log(gorder(login_network))

# decomposition statistics 
decomposition_stats <- table(sapply(decompose.graph(login_network), vcount))

net_comm_det <- data.frame(event="net_comm_det", time=now("EST"))
time_log <- rbind(time_log, net_comm_det); rm(net_comm_det)

# now, we need to construct a nodelist 
nodelist <- data.frame(id = c(1:(igraph::vcount(login_network))), login = igraph::V(login_network)$name)

# degree, weighted degree, k core and modularity 
node_stats_start <- data.frame(event="node_stats_start", time=now("EST"))
time_log <- rbind(time_log, node_stats_start); rm(node_stats_start)
nodelist$degree <- degree(login_network)
nodelist$wtd_degree <- strength(login_network)
nodelist$k_core <- coreness(login_network)
#louvain <- cluster_louvain(login_network)
nodelist$louvain_comm <- louvain$membership
#fstgrdy <- fastgreedy.community(login_network)
#nodelist$fstgrdy_comm <- fstgrdy$membership
components <- components(login_network)
nodelist$component <- components$membership

node_stats_end <- data.frame(event="node_stats_end", time=now("EST"))
time_log <- rbind(time_log, node_stats_end); rm(node_stats_end, louvain, components)

#setwd("~/intl-dyn-ctr-nets-cum")
#saveRDS(network_stats, "global_netstats_2008-17.rds")  
#saveRDS(decomposition_stats, "decomposition_stats_2008-17.rds") 
#saveRDS(nodelist, "nodelist_2008-17.rds")  
#saveRDS(time_log, "timelog_2008-17.rds")
```

















