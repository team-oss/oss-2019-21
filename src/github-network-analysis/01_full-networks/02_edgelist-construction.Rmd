---
title: "PostgreSQL Edgelist Creation"
output: html_document
---

The purpose of this file is to share the PostgreSQL code that converts user's contributions to repos (i.e. a bipartite edgelist) into contributor edgelists with shared repos, shared commits, shared additions and shared deletions as columns for use as edge weights. This code bypasses the need to project bipartite matrices and all of the problems this creates. 

First we will create a toy dataset of contributions so that we can test our code. We create the data and write it to the database. 

```{r testing postgresql code for edgelist_data, include=FALSE}

# first, we create some toy data 
login <- c("brandon","bayoan","gizem","brandon","gizem","teja","kathryn")
slug  <- c("oss", "oss", "oss", "ffx", "oss", "ffx", "ffx")
committed_date <- as.Date(c('2018-01-01 13:35:08-05', '2018-01-01 13:35:08-05',
                            '2018-01-01 13:35:08-05', '2017-01-01 13:35:08-05',
                            '2017-01-01 13:35:08-05', '2017-01-01 13:35:08-05',
                            '2017-01-01 13:35:08-05'))
additions <- c(3,5,7,10,3,4,3)
deletions <- c(2,2,2,2,2,2,2)
test_data <- data.frame(login, slug, committed_date, additions, deletions)

# then we connect to the database 
library(RPostgreSQL)

# connect to postgresql to get data (in rivanna)
conn <- dbConnect(drv = PostgreSQL(), 
                  dbname = "sdad", 
                  host = "10.250.124.195", 
                  port = 5432, 
                  user = Sys.getenv("db_userid"), 
                  password = Sys.getenv("db_pwd"))

dbWriteTable(conn, 
             name = c(schema = "gh" , 
                      name = "test_data"), 
             value = test_data, 
             row.names = FALSE)

dbDisconnect(conn)

```

```{sql test}

-- then we plug this code into the database 
SELECT ctr1,
       ctr2,
       YEAR,
       COUNT(*) AS repo_wts,
       SUM(commits) AS commits_wts,
       SUM(additions) AS additions_wts,
       SUM(deletions) AS deletions_wts
FROM
  (SELECT A.slug,
          A.year,
          A.login AS ctr1,
          B.login AS ctr2,
          A.commits,
          A.additions,
          A.deletions
   FROM
     (SELECT slug,
             YEAR,
             login,
             COUNT(*) AS commits,
             SUM(additions) AS additions,
             SUM(deletions) AS deletions
      FROM
        (SELECT login,
                slug,
                EXTRACT(YEAR
                        FROM committed_date)::int AS YEAR,
                additions,
                deletions
         FROM gh.commits
         LIMIT 500) A
      GROUP BY slug,
               YEAR,
               login) A
   INNER JOIN
     (SELECT slug,
             YEAR,
             login,
             COUNT(*) AS commits,
             SUM(additions) AS additions,
             SUM(deletions) AS deletions
      FROM
        (SELECT login,
                slug,
                EXTRACT(YEAR
                        FROM committed_date)::int AS YEAR,
                additions,
                deletions
         FROM gh.commits
         LIMIT 500) A
      GROUP BY slug,
               YEAR,
               login) B ON A.slug = B.slug
   AND A.year = B.year
   WHERE A.login <= B.login) A   --- UPDATED 
GROUP BY YEAR,
         ctr1,
         ctr2;
         
--this is what the data should look like...          
--brandon gizem 2018 1 8 4 
--brandon bayoan 2018 1 
--gizem bayoan 2017 1 
--brandon teja 2017 1
--brandon kathryn 2017 1 

```


```{sql sna_ctr_edgelist}

--then we write the actual data to the database (as a materialized view table)
CREATE MATERIALIZED VIEW gh.sna_ctr_edgelist AS (
SELECT ctr1,
       ctr2,
       YEAR,
       COUNT(*) AS repo_wts
FROM
  (SELECT A.slug,
          A.year,
          A.login AS ctr1,
          B.login AS ctr2,
          A.commits 
   FROM
     (SELECT slug,
             YEAR,
             login,
             COUNT(*) AS commits
      FROM
        (SELECT login,
                slug,
                EXTRACT(YEAR
                        FROM committed_date)::int AS YEAR
         FROM gh.commits) A
      GROUP BY slug,
               YEAR,
               login) A
   INNER JOIN
     (SELECT slug,
             YEAR,
             login,
             COUNT(*) AS commits
      FROM
        (SELECT login,
                slug,
                EXTRACT(YEAR
                        FROM committed_date)::int AS YEAR
         FROM gh.commits) A
      GROUP BY slug,
               YEAR,
               login) B ON A.slug = B.slug
   AND A.year = B.year
   WHERE A.login <= B.login) A
GROUP BY YEAR,
         ctr1,
         ctr2
);
```

```{sql sna_ctr_edgelist}

--then we write the actual data to the database (as a materialized view table)
CREATE MATERIALIZED VIEW gh.sna_ctr_edgelist AS (
SELECT ctr1,
       ctr2,
       YEAR,
       COUNT(*) AS repo_wts
FROM
  (SELECT A.slug,
          A.year,
          A.login AS ctr1,
          B.login AS ctr2,
          A.commits 
   FROM
     (SELECT slug,
             YEAR,
             login,
             COUNT(*) AS commits
      FROM
        (SELECT login,
                slug,
                EXTRACT(YEAR
                        FROM committed_date)::int AS YEAR
         FROM gh.commits
         WHERE login IS NOT NULL) A
      GROUP BY slug,
               YEAR,
               login) A
   INNER JOIN
     (SELECT slug,
             YEAR,
             login,
             COUNT(*) AS commits
      FROM
        (SELECT login,
                slug,
                EXTRACT(YEAR
                        FROM committed_date)::int AS YEAR
         FROM gh.commits
         WHERE login IS NOT NULL) A
      GROUP BY slug,
               YEAR,
               login) B ON A.slug = B.slug
   AND A.year = B.year
   WHERE A.login <= B.login) A  --- corrected code for self-loops 
GROUP BY YEAR,
         ctr1,
         ctr2
);
```


```{sql sna_intl_ctr_edgelist}

--FIRST WE ARE GOING TO INDEX THE CONTRIBUTOR COLUMNS IN THE ORIGINAL EDGELIST 
CREATE INDEX sna_ctr_edgelist_ctr1_idx ON gh.sna_ctr_edgelist (ctr1); 
CREATE INDEX sna_ctr_edgelist_ctr2_idx ON gh.sna_ctr_edgelist (ctr2); 

--THIS FILTERS THE ORIGINAL EDGELIST DOWN TO ONLY THOSE WITH VALID COUNTRY CODES 
CREATE MATERIALIZED VIEW gh.sna_intl_ctr_edgelist AS (
SELECT ctr_el.ctr1, ctr_el.ctr2, ctr_el.year, ctr_el.repo_wts  
FROM gh.sna_ctr_edgelist AS ctr_el
INNER JOIN github.users_gh_cc AS cc1 ON cc1.login = ctr_el.ctr1 OR cc1.login = ctr_el.ctr2 
WHERE cc1.country_code IS NOT NULL AND cc1.country_code IS NOT NULL
); 

```







```{sql sna_repo_edgelist}

-- as of march 9th this is not right... 

CREATE MATERIALIZED VIEW gh.sna_repo_edgelist AS (
SELECT repo1,
       repo2,
       YEAR,
       COUNT(*) AS weight
FROM
  (SELECT A.login,
          A.year,
          A.slug AS repo1,
          B.slug AS repo2,
          A.commits
   FROM
     (SELECT login,
             YEAR,
             slug,
             COUNT(*) AS commits
      FROM
        (SELECT slug,
                login,
                EXTRACT(YEAR
                        FROM committed_date)::int AS YEAR
         FROM gh.commits
         LIMIT 500) A
      GROUP BY login,
               YEAR,
               slug) A
   INNER JOIN
     (SELECT login,
             YEAR,
             slug,
             COUNT(*) AS commits
      FROM
        (SELECT slug,
                login,
                EXTRACT(YEAR
                        FROM committed_date)::int AS YEAR
         FROM gh.commits
         LIMIT 500) A
      GROUP BY login,
               YEAR,
               slug) B ON A.login = B.login
   AND A.year = B.year
   WHERE A.slug < B.slug) A
GROUP BY YEAR,
         repo1,
         repo2
);

```

```{sql}

SELECT login, 
       COUNT(*) AS commits, 
       SUM(additions), 
       SUM (deletions) 
FROM gh.commits 
GROUP BY 
INNER JOIN (SELECT login, 
                   company, 
                   EXTRACT(YEAR FROM created_at)::int AS year, 
                   country_code, 
                   state, 
                   city, 
                   location 
            FROM github.users_gh
            LIMIT 500) A
ON A.login = B.login
GROUP BY 
--WHERE B.login IS NOT NULL 
            
```


```{sql}

-- international edgelist (need to test to make sure)
-- may need to download full edgelist from gh_torrent data, recode country_code and then validate 

CREATE MATERIALIZED VIEW sna_intl_ctr_edgelist AS (
SELECT ctr_el.ctr1, ctr_el.ctr2, ctr_el.year, ctr_el.repo_wts  
FROM gh.sna_ctr_edgelist AS ctr_el
INNER JOIN github.users_gh_cc AS cc1 ON cc1.login = ctr_el.ctr1 OR cc1.login = ctr_el.ctr2 
WHERE cc1.country_code IS NOT NULL AND cc1.country_code IS NOT NULL
); 

```

```{sql}



SELECT ctr_el.ctr1, ctr_el.ctr2, ctr_el.year, ctr_el.repo_wts
FROM gh.sna_ctr_edgelist AS ctr_el
INNER JOIN github.users_gh_cc AS cc1 ON cc1.login = ctr_el.ctr1 OR cc2.login = ctr_el.ctr2 
WHERE cc1.country_code IS NOT NULL AND cc1.country_code IS NOT NULL 
LIMIT 50; 


-- company edgelist (need to test to make sure)
-- may need to download full edgelist from gh_torrent data, recode cmpy_code and then validate 

CREATE MATERIALIZED VIEW sna_cmpy_ctr_edgelist AS (

SELECT t1.ctr1, t1.ctr2, t1.weight, t2.login, t2.cmpy_code 
FROM sna_ctr_edgelist AS t1, gh_users_cmpy AS t2 
WHERE t1.ctr1 = t2.login, t2.cmpy_code IS NOT NULL 

)

```










