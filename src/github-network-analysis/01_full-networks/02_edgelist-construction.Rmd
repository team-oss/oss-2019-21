---
title: "PostgreSQL Edgelist Creation"
output: html_document
---

The purpose of this file is to share the PostgreSQL code that converts user's contributions to repos (i.e. a bipartite edgelist) into contributor edgelists with shared repos, shared commits, shared additions and shared deletions as columns for use as edge weights. This code bypasses the need to project bipartite matrices and all of the problems this creates. 

First we will create a toy dataset of contributions so that we can test our code. We create the data and write it to the database. 

```{r testing postgresql code for edgelist_data, include=FALSE}

# first, we create some toy data 
login <- c("brandon","bayoan","gizem","brandon","gizem","teja","kathryn")
slug  <- c("oss", "oss", "oss", "ffx", "oss", "ffx", "ffx")
committed_date <- as.Date(c('2018-01-01 13:35:08-05', '2018-01-01 13:35:08-05',
                            '2018-01-01 13:35:08-05', '2017-01-01 13:35:08-05',
                            '2017-01-01 13:35:08-05', '2017-01-01 13:35:08-05',
                            '2017-01-01 13:35:08-05'))
additions <- c(3,5,7,10,3,4,3)
deletions <- c(2,2,2,2,2,2,2)
test_data <- data.frame(login, slug, committed_date, additions, deletions)

# then we connect to the database 
library(RPostgreSQL)

# connect to postgresql to get data (in rivanna)
conn <- dbConnect(drv = PostgreSQL(), 
                  dbname = "sdad", 
                  host = "10.250.124.195", 
                  port = 5432, 
                  user = Sys.getenv("db_userid"), 
                  password = Sys.getenv("db_pwd"))

dbWriteTable(conn, 
             name = c(schema = "gh" , 
                      name = "test_data"), 
             value = test_data, 
             row.names = FALSE)

dbDisconnect(conn)

```

```{sql test}

-- then we plug this code into the database 
SELECT ctr1,
       ctr2,
       YEAR,
       COUNT(*) AS repo_wts,
       SUM(commits) AS commits_wts,
       SUM(additions) AS additions_wts,
       SUM(deletions) AS deletions_wts
FROM
  (SELECT A.slug,
          A.year,
          A.login AS ctr1,
          B.login AS ctr2,
          A.commits,
          A.additions,
          A.deletions
   FROM
     (SELECT slug,
             YEAR,
             login,
             COUNT(*) AS commits,
             SUM(additions) AS additions,
             SUM(deletions) AS deletions
      FROM
        (SELECT login,
                slug,
                EXTRACT(YEAR
                        FROM committed_date)::int AS YEAR,
                additions,
                deletions
         FROM gh.commits
         LIMIT 500) A
      GROUP BY slug,
               YEAR,
               login) A
   INNER JOIN
     (SELECT slug,
             YEAR,
             login,
             COUNT(*) AS commits,
             SUM(additions) AS additions,
             SUM(deletions) AS deletions
      FROM
        (SELECT login,
                slug,
                EXTRACT(YEAR
                        FROM committed_date)::int AS YEAR,
                additions,
                deletions
         FROM gh.commits
         LIMIT 500) A
      GROUP BY slug,
               YEAR,
               login) B ON A.slug = B.slug
   AND A.year = B.year
   WHERE A.login < B.login) A
GROUP BY YEAR,
         ctr1,
         ctr2;
         
--this is what the data should look like...          
--brandon gizem 2018 1 8 4 
--brandon bayoan 2018 1 
--gizem bayoan 2017 1 
--brandon teja 2017 1
--brandon kathryn 2017 1 

```


```{sql sna_ctr_edgelist}

--then we write the actual data to the database (as a materialized view table)
CREATE MATERIALIZED VIEW gh.sna_ctr_edgelist AS (
SELECT ctr1,
       ctr2,
       YEAR,
       COUNT(*) AS weight
FROM
  (SELECT A.slug,
          A.year,
          A.login AS ctr1,
          B.login AS ctr2,
          A.commits
   FROM
     (SELECT slug,
             YEAR,
             login,
             COUNT(*) AS commits
      FROM
        (SELECT login,
                slug,
                EXTRACT(YEAR
                        FROM committed_date)::int AS YEAR
         FROM gh.commits) A
      GROUP BY slug,
               YEAR,
               login) A
   INNER JOIN
     (SELECT slug,
             YEAR,
             login,
             COUNT(*) AS commits
      FROM
        (SELECT login,
                slug,
                EXTRACT(YEAR
                        FROM committed_date)::int AS YEAR
         FROM gh.commits) A
      GROUP BY slug,
               YEAR,
               login) B ON A.slug = B.slug
   AND A.year = B.year
   WHERE A.login < B.login) A
GROUP BY YEAR,
         ctr1,
         ctr2
);
```

```{sql sna_repo_edgelist}

CREATE MATERIALIZED VIEW gh.sna_repo_edgelist AS (
SELECT repo1,
       repo2,
       YEAR,
       COUNT(*) AS weight
FROM
  (SELECT A.login,
          A.year,
          A.slug AS repo1,
          B.slug AS repo2,
          A.commits
   FROM
     (SELECT login,
             YEAR,
             slug,
             COUNT(*) AS commits
      FROM
        (SELECT slug,
                login,
                EXTRACT(YEAR
                        FROM committed_date)::int AS YEAR
         FROM gh.commits) A
      GROUP BY login,
               YEAR,
               slug) A
   INNER JOIN
     (SELECT login,
             YEAR,
             slug,
             COUNT(*) AS commits
      FROM
        (SELECT slug,
                login,
                EXTRACT(YEAR
                        FROM committed_date)::int AS YEAR
         FROM gh.commits) A
      GROUP BY login,
               YEAR,
               slug) B ON A.login = B.login
   AND A.year = B.year
   WHERE A.slug < B.slug) A
GROUP BY YEAR,
         repo1,
         repo2
);

```

```{sql}

SELECT login, 
       COUNT(*) AS commits, 
       SUM(additions), 
       SUM (deletions) 
FROM gh.commits 
GROUP BY 
INNER JOIN (SELECT login, 
                   company, 
                   EXTRACT(YEAR FROM created_at)::int AS year, 
                   country_code, 
                   state, 
                   city, 
                   location 
            FROM github.users_gh
            LIMIT 500) A
ON A.login = B.login
GROUP BY 
--WHERE B.login IS NOT NULL 
            
```


```{sql}

-- international edgelist (need to test to make sure)
-- may need to download full edgelist from gh_torrent data, recode country_code and then validate 

CREATE MATERIALIZED VIEW sna_intl_ctr_edgelist AS (

SELECT t1.ctr1, t1.ctr2, t1.weight, t2.login, t2.country_code 
FROM sna_ctr_edgelist AS t1, gh_users_cc AS t2 
WHERE t1.ctr1 = t2.login, t2.country_code IS NOT NULL 

)

```

```{sql}

-- company edgelist (need to test to make sure)
-- may need to download full edgelist from gh_torrent data, recode cmpy_code and then validate 

CREATE MATERIALIZED VIEW sna_cmpy_ctr_edgelist AS (

SELECT t1.ctr1, t1.ctr2, t1.weight, t2.login, t2.cmpy_code 
FROM sna_ctr_edgelist AS t1, gh_users_cmpy AS t2 
WHERE t1.ctr1 = t2.login, t2.cmpy_code IS NOT NULL 

)

```










